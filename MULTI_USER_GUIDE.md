# 👥 다중 사용자 동작 가이드

## 현재 시스템의 다중 사용자 지원

### 아키텍처 개요

```
사용자 A (user_id: 1)
  └─ 크롤링 작업 1 (job_id: 1) → 독립 실행
  └─ 크롤링 작업 2 (job_id: 2) → 독립 실행

사용자 B (user_id: 2)
  └─ 크롤링 작업 3 (job_id: 3) → 독립 실행
  └─ 크롤링 작업 4 (job_id: 4) → 독립 실행
```

### 동시 실행 가능 여부

**✅ 가능:**
- 사용자 A와 사용자 B가 동시에 크롤링 시작 가능
- 각 사용자는 자신의 작업만 확인
- 서로의 진행률에 영향 없음

**❌ 제한:**
- 같은 사용자는 한 번에 하나의 작업만 실행 가능
- 이미 실행 중인 작업이 있으면 새 작업 시작 불가

### 데이터 격리

**사용자별 데이터:**
- 크롤링 작업: `CrawlingJob.user_id`로 구분
- 진행률: 사용자별로 독립적으로 관리
- 결과 파일: 사용자별로 별도 저장

**데이터베이스:**
```python
# 사용자 A의 작업만 조회
jobs = db.query(CrawlingJob).filter(
    CrawlingJob.user_id == current_user.id
).all()
```

## 동시 사용 시나리오

### 시나리오 1: 여러 사용자 동시 크롤링

```
시간: 10:00
- 사용자 A: SSG 크롤링 시작 (100개 제품)
- 사용자 B: 신세계 쇼핑 크롤링 시작 (50개 제품)
- 사용자 C: 삼성 크롤링 시작 (30개 제품)

→ 모두 동시에 실행 가능
→ 각자 독립적으로 진행
→ 서로 영향 없음
```

### 시나리오 2: 같은 사용자 중복 요청

```
시간: 10:00
- 사용자 A: SSG 크롤링 시작

시간: 10:01
- 사용자 A: 신세계 쇼핑 크롤링 시작 시도
→ ❌ "이미 크롤링이 진행 중입니다" 에러
→ 첫 번째 작업 완료 후 가능
```

## 성능 및 확장성

### 현재 제한사항

**SQLite 데이터베이스:**
- 동시 쓰기 제한 (Write-Ahead Logging 사용 시 개선)
- 읽기는 병렬 가능
- 소규모 사용자(10-20명)까지는 문제없음

**권장:**
- 사용자가 많을 경우 PostgreSQL로 전환
- Render에서 PostgreSQL 서비스 추가 가능

### 리소스 사용

**메모리:**
- 사용자당 크롤러 인스턴스 1개
- 각 인스턴스는 약 10-50MB 메모리 사용

**CPU:**
- 크롤링은 I/O 바운드 (네트워크 대기)
- CPU 사용률은 낮음

**네트워크:**
- 각 사용자가 독립적으로 요청
- 타겟 사이트의 Rate Limiting 고려 필요

## 확장성 개선 방안

### 1. 데이터베이스 업그레이드

**PostgreSQL로 전환:**
```python
# Render에서 PostgreSQL 서비스 추가
DATABASE_URL = postgresql://user:pass@host:port/dbname
```

**장점:**
- 동시 쓰기 지원
- 더 많은 사용자 지원 가능
- 데이터 무결성 보장

### 2. 작업 큐 시스템

**Celery + Redis 사용:**
- 비동기 작업 처리
- 작업 우선순위 관리
- 재시도 로직

**장점:**
- 더 많은 동시 작업 처리
- 작업 실패 시 자동 재시도
- 작업 상태 추적

### 3. 로드 밸런싱

**여러 서버 인스턴스:**
- Render Pro 플랜에서 가능
- 여러 인스턴스로 부하 분산

## 모니터링

### 사용자별 통계

**관리자 페이지에서 확인:**
- 전체 사용자 수
- 활성 사용자 수
- 진행 중인 작업 수
- 완료된 작업 수

### 로그 확인

**Render Dashboard:**
- 실시간 로그 확인
- 사용자별 요청 추적
- 에러 모니터링

## 결론

**현재 시스템:**
- ✅ 여러 사용자 동시 사용 가능
- ✅ 사용자별 데이터 격리
- ✅ 소규모 사용자(10-20명)까지 문제없음

**확장 필요 시:**
- PostgreSQL로 전환
- 작업 큐 시스템 도입
- 로드 밸런싱 고려

